/*
 * @(#)J3dland_chisel.java
 *
 * Copyright (c) 1999 by Trapezium Development LLC.  All Rights Reserved.
 *
 * The information in this file is the property of Trapezium Development LLC
 * and may be used only in accordance with the terms of the license granted
 * by Trapezium.
 *
 */
package com.trapezium.chisel.codeveloper;

import com.trapezium.chisel.Optimizer;
import com.trapezium.chisel.TokenPrinter;
import com.trapezium.chisel.IntegerConstraints;
import com.trapezium.vrml.node.*;
import com.trapezium.vrml.fields.*;

/**
 * J3dland_chisel is a custom chisel designed by your name here
 *
 * This code was generated by Chisel Developer Kit version 1.0
 */
public class J3dland_chisel extends Optimizer {
	// constants defining options by offset
	static final int UNUSED_OPTION_1_ONOFF_VALUE_OPTION = 0;
	static final int UNUSED_OPTION_2_NUMERIC_VALUE_OPTION = 1;

	// variables for storing option values
	boolean unused_option_1_onoff_value;
	int unused_option_2_numeric_value;

	public J3dland_chisel() {
		super( "Material", "your description here" );
		unused_option_1_onoff_value = true;
		unused_option_2_numeric_value = 3;
	}

	/** reset called just before chisel is run on a new file */
	public void reset() {
	}

	/** Get the number of options available for this chisel */
	public int getNumberOptions() {
		return( 2 );
	}

	/** Get the data type of an option */
	public Class getOptionClass( int offset ) {
		if ( offset == UNUSED_OPTION_1_ONOFF_VALUE_OPTION ) {
			return( Boolean.TYPE );
		}
		if ( offset == UNUSED_OPTION_2_NUMERIC_VALUE_OPTION ) {
			return( Integer.TYPE );
		}
		return( null );
	}

	/** Get the label for an option */
	public String getOptionLabel( int offset ) {
		if ( offset == UNUSED_OPTION_1_ONOFF_VALUE_OPTION ) {
			return( "unused option 1, on/off value" );
		}
		if ( offset == UNUSED_OPTION_2_NUMERIC_VALUE_OPTION ) {
			return( "unused option 2, numeric value" );
		}
		return( null );
	}

	/** Get the value of an option */
	public Object getOptionValue( int offset ) {
		if ( offset == UNUSED_OPTION_1_ONOFF_VALUE_OPTION ) {
			return( booleanToOptionValue( unused_option_1_onoff_value ));
		}
		if ( offset == UNUSED_OPTION_2_NUMERIC_VALUE_OPTION ) {
			return( intToOptionValue( unused_option_2_numeric_value ));
		}
		return( null );
	}

	/** Set the value of an option */
	public void setOptionValue( int offset, Object value ) {
		if ( offset == UNUSED_OPTION_1_ONOFF_VALUE_OPTION ) {
			unused_option_1_onoff_value = optionValueToBoolean( value );
		}
		if ( offset == UNUSED_OPTION_2_NUMERIC_VALUE_OPTION ) {
			unused_option_2_numeric_value = optionValueToInt( value );
		}
	}

	/** Get the constraints on an option */
	public Object getOptionConstraints( int offset ) {
		if ( offset == UNUSED_OPTION_2_NUMERIC_VALUE_OPTION ) {
			return( new IntegerConstraints( 1, 7, 2 ));
		}
		return( null );
	}

	/** Check if Node should be modified.
	 * TODO: user defined
	 */
	boolean optimizationOK( Node n ) {
		// MUST BE USER DEFINED
		return( true );
	}

	/** Called when node of specified type found in graph traversal */
	public void attemptOptimization( Node n ) {
		if ( optimizationOK( n )) {
			// if you need to access any of the fields, here they are
			// Field value is null if field not specified in file
			Field specularColor = n.getField( "specularColor" );
			Field shininess = n.getField( "shininess" );
			Field diffuseColor = n.getField( "diffuseColor" );
			Field ambientIntensity = n.getField( "ambientIntensity" );
			Field emissiveColor = n.getField( "emissiveColor" );
			Field transparency = n.getField( "transparency" );

			// register entire node for regeneration
			// last parameter can be any object, it is passed to "optimize" method
			// as the "param" parameter
			replaceRange( n.getFirstTokenOffset(), n.getLastTokenOffset(), n );
		}
	}

	/** Called to regenerate a portion of the text in a file.
	 *
	 *  @param tp object that takes regenerated text, similar to a PrintStream
	 *  @param param Object passed to "replaceRange" in "attemptOptimization" method above
	 *  @param startTokenOffset offset of first token in sequence being regenerated
	 *  @param endTokenOffset offset of last token in sequence being regenerated
	 */
	public void optimize( TokenPrinter tp, Object param, int startTokenOffset, int endTokenOffset ) {
		// TODO: user defined
		// if nothing done here, entire range is removed
	}

}
