package com.trapezium.cdk;
import java.lang.*;
import java.io.*;
import java.util.Hashtable;
import java.util.Enumeration;
import com.trapezium.vrml.grammar.VRML97;

public class ChiselGenerator extends java.lang.Object implements java.io.Serializable
{
    static final int MaxOptions = 8;
    OptionInfo[] optionInfo;
    boolean modifiesNodes;
    boolean modifiesRoutes;
    String nodeType;

    public ChiselGenerator() {
        modifiesNodes = true;
        modifiesRoutes = false;
        optionInfo = new OptionInfo[MaxOptions];
        for ( int i = 0; i < MaxOptions; i++ ) {
            optionInfo[i] = new OptionInfo();
        }
        nodeType = null;
    }
    
    public void setNodeType( String nodeType ) {
        this.nodeType = nodeType;
    }
    
    public void setNodeModifier( boolean value ) {
        modifiesNodes = value;
    }
    
    public void setRouteModifier( boolean value ) {
        modifiesRoutes = value;
    }

    public int getNumberOptions() {
        int numberOptions = 0;
        for ( int i = 0; i < MaxOptions; i++ ) {
            if ( optionInfo[i].hasDescription() ) {
                numberOptions++;
            }
        }
        return( numberOptions );
    }

    public OptionInfo getValidOption( int offset ) {
        int currentOffset = 0;
        for ( int i = 0; i < MaxOptions; i++ ) {
            if ( optionInfo[i].hasDescription() ) {
                if ( offset == currentOffset ) {
                    return( optionInfo[i] );
                } else {
                    currentOffset++;
                }
            }
        }
        return( null );
    }

    public OptionInfo getOptionInfo( int offset ) {
        offset--;
        return( optionInfo[offset] );
    }

	/** This is the generic java code generating stuff... */
    String codeveloperFile;
    String getGeneratedFileName() {
        return( codeveloperFile + ".java" );
    }
	void genChisel( String codeveloper, String shortDescription, String longDescription ) {
	    String packageName = genPackageName( shortDescription );
	    try {
    	    FileOutputStream fos = new FileOutputStream( new File( codeveloperFile + ".java" ));
    	    System.out.println( "Generating file " + codeveloperFile + ".java" );
    	    PrintStream ps = new PrintStream( fos );
            ps.println( "/*" );
            ps.println( " * @(#)" + codeveloperFile + ".java" );
            ps.println( " *" );
            ps.println( " * Copyright (c) 1999 by Trapezium Development LLC.  All Rights Reserved." );
            ps.println( " *" );
            ps.println( " * The information in this file is the property of Trapezium Development LLC" );
            ps.println( " * and may be used only in accordance with the terms of the license granted" );
            ps.println( " * by Trapezium." );
            ps.println( " *" );
            ps.println( " */" );
            ps.println( "package com.trapezium.chisel.codeveloper;" );
    	    ps.println( "" );
    	    ps.println( "import com.trapezium.chisel.Optimizer;" );
    	    ps.println( "import com.trapezium.chisel.TokenPrinter;" );
    	    ps.println( "import com.trapezium.chisel.IntegerConstraints;" );
    	    ps.println( "import com.trapezium.vrml.node.*;" );
    	    ps.println( "import com.trapezium.vrml.fields.*;" );
    	    ps.println( "" );
    	    ps.println( "/**" );
    	    ps.println( " * " + codeveloperFile + " is a custom chisel designed by " + codeveloper );
    	    ps.println( " *" );
    	    ps.println( " * This code was generated by Chisel Developer Kit version 1.0" );
    	    ps.println( " */" );
    	    ps.println( "public class " + codeveloperFile + " extends Optimizer {" );
    	    
    	    int numberOptions = getNumberOptions();
    	    String[] optionConstants = null;
    	    String[] optionVariables = null;
    	    boolean[] optionIsBool = null;
    	    String[] optionDescriptions = null;
    	    boolean[] optionBoolVal = null;
    	    int[] optionDefaultVal = null;
    	    int[] optionMinVal = null;
    	    int[] optionMaxVal = null;
    	    int[] optionIncVal = null;
    	    if ( numberOptions > 0 ) {
    	        optionConstants = new String[ numberOptions ];
    	        optionVariables = new String[ numberOptions ];
    	        optionIsBool = new boolean[ numberOptions ];
    	        optionDescriptions = new String[ numberOptions ];
    	        optionBoolVal = new boolean[ numberOptions ];
    	        optionDefaultVal = new int[ numberOptions ];
    	        optionMinVal = new int[ numberOptions ];
    	        optionMaxVal = new int[ numberOptions ];
    	        optionIncVal = new int[ numberOptions ];
    	        for ( int i = 0; i < numberOptions; i++ ) {
    	            OptionInfo option = getValidOption( i );
    	            optionConstants[i] = strToUpper( option.getDescription() ) + "_OPTION";
    	            optionVariables[i] = strToName( option.getDescription() );
    	            optionDescriptions[i] = option.getDescription();
    	            optionIsBool[i] = option.isBool();
    	            optionBoolVal[i] = option.getBoolVal();
    	            optionDefaultVal[i] = option.getDefaultVal();
    	            optionMinVal[i] = option.getMinVal();
    	            optionMaxVal[i] = option.getMaxVal();
    	            optionIncVal[i] = option.getIncVal();
    	        }
    	        ps.println( "\t// constants defining options by offset" );
    	        for ( int i = 0; i < numberOptions; i++ ) {
    	            ps.println( "\tstatic final int " + optionConstants[i] + " = " + i + ";" );
    	        }
    	        ps.println( "" );
    	        ps.println( "\t// variables for storing option values" );
    	        for ( int i = 0; i < numberOptions; i++ ) {
    	            if ( optionIsBool[i] ) {
    	                ps.println( "\tboolean " + optionVariables[i] + ";" );
    	            } else {
    	                ps.println( "\tint " + optionVariables[i] + ";" );
    	            }
    	        }
    	        ps.println( "" );
       	    }
    	    
    	    ps.println( "\tpublic " + codeveloperFile + "() {" );
    	    if ( nodeType != null ) {
    	        ps.println( "\t\tsuper( \"" + nodeType + "\", \"" + longDescription + "\" );" );
    	    }
    	    if ( numberOptions > 0 ) {
    	        for ( int i = 0; i < numberOptions; i++ ) {
    	            if ( optionIsBool[i] ) {
    	                genOptionBool( ps, optionVariables[i], optionBoolVal[i] );
    	            } else {
    	                genOptionDefault( ps, optionVariables[i], optionDefaultVal[i] );
    	            }
    	        }
    	    }
    	    ps.println( "\t}" );
    	    ps.println( "" );
    	    ps.println( "\t/** reset called just before chisel is run on a new file */" );
    	    ps.println( "\tpublic void reset() {" );
    	    ps.println( "\t}" );
    	    ps.println( "" );
            if ( numberOptions > 0 ) {
           	    ps.println( "\t/** Get the number of options available for this chisel */" );
    	        ps.println( "\tpublic int getNumberOptions() {" );
        	    ps.println( "\t\treturn( " + numberOptions + " );" );
        	    ps.println( "\t}" );
        	    ps.println( "" );
        	    ps.println( "\t/** Get the data type of an option */" );
        	    ps.println( "\tpublic Class getOptionClass( int offset ) {" );
        	    for ( int i = 0; i < numberOptions; i++ ) {
            	    genOptionTypeReturn( ps, optionConstants[i], optionIsBool[i] );
            	}
            	ps.println( "\t\treturn( null );" );
            	ps.println( "\t}" );
            	ps.println( "" );
            	ps.println( "\t/** Get the label for an option */" );
            	ps.println( "\tpublic String getOptionLabel( int offset ) {" );
            	for ( int i = 0; i < numberOptions; i++ ) {
            	    genOptionLabelReturn( ps, optionConstants[i], optionDescriptions[i] );
            	}
            	ps.println( "\t\treturn( null );" );
            	ps.println( "\t}" );
            	ps.println( "" );
            	ps.println( "\t/** Get the value of an option */" );
            	ps.println( "\tpublic Object getOptionValue( int offset ) {" );
            	for ( int i = 0; i < numberOptions; i++ ) {
            	    genOptionValueReturn( ps, optionConstants[i], optionIsBool[i], optionVariables[i] );
            	}
            	ps.println( "\t\treturn( null );" );
            	ps.println( "\t}" );
            	ps.println( "" );
            	ps.println( "\t/** Set the value of an option */" );
            	ps.println( "\tpublic void setOptionValue( int offset, Object value ) {" );
            	for ( int i = 0; i < numberOptions; i++ ) {
            	    genOptionValueSet( ps, optionConstants[i], optionIsBool[i], optionVariables[i] );
            	}
            	ps.println( "\t}" );
            	ps.println( "" );
            	ps.println( "\t/** Get the constraints on an option */" );
            	ps.println( "\tpublic Object getOptionConstraints( int offset ) {" );
            	for ( int i = 0; i < numberOptions; i++ ) {
            	    genOptionConstraints( ps, optionConstants[i], optionIsBool[i], optionMinVal[i], optionMaxVal[i], optionIncVal[i] );
            	}
            	ps.println( "\t\treturn( null );" );
            	ps.println( "\t}" );
            	ps.println( "" );
       	    }
       	    if ( modifiesNodes ) {
       	        ps.println( "\t/** Check if Node should be modified." );
       	        ps.println( "\t * TODO: user defined" );
       	        ps.println( "\t */" );
       	        ps.println( "\tboolean optimizationOK( Node n ) {" );
       	        ps.println( "\t\t// MUST BE USER DEFINED" );
       	        ps.println( "\t\treturn( true );" );
       	        ps.println( "\t}" );
       	        ps.println( "" );
       	        ps.println( "\t/** Called when node of specified type found in graph traversal */" );
       	        ps.println( "\tpublic void attemptOptimization( Node n ) {" );
       	        ps.println( "\t\tif ( optimizationOK( n )) {" );
       	        if ( nodeType != null ) {
           	        ps.println( "\t\t\t// if you need to access any of the fields, here they are" );
           	        ps.println( "\t\t\t// Field value is null if field not specified in file" );
           	        String[] fieldNameList = getFieldNames( nodeType );
           	        if ( fieldNameList == null ) {
           	            ps.println( "\t\t\t// '" + nodeType + "' is not a build in node type" );
           	        } else {
           	            for ( int i = 0; i < fieldNameList.length; i++ ) {
           	                ps.println( "\t\t\tField " + fieldNameList[i] + " = n.getField( \"" + fieldNameList[i] + "\" );" );
           	            }
           	        }
           	        ps.println( "" );
           	    }
       	        ps.println( "\t\t\t// register entire node for regeneration" );
       	        ps.println( "\t\t\t// last parameter can be any object, it is passed to \"optimize\" method" );
       	        ps.println( "\t\t\t// as the \"param\" parameter" );
       	        ps.println( "\t\t\treplaceRange( n.getFirstTokenOffset(), n.getLastTokenOffset(), n );" );
       	        ps.println( "\t\t}" );
       	        ps.println( "\t}" );
       	        ps.println( "" );
       	    }
      	    if ( modifiesRoutes ) {
       	        ps.println( "\t/** Check if ROUTE should be modified." );
       	        ps.println( "\t * TODO: user defined" );
       	        ps.println( "\t */" );
       	        ps.println( "\tboolean optimizationOK( ROUTE route ) {" );
       	        ps.println( "\t\t// MUST BE USER DEFINED" );
       	        ps.println( "\t\treturn( true );" );
       	        ps.println( "\t}" );
       	        ps.println( "" );
       	        ps.println( "\t/** Called when a ROUTE is found in graph traversal */" );
       	        ps.println( "\tpublic void attemptOptimization( ROUTE route ) {" );
       	        ps.println( "\t\tif ( optimizationOK( route )) {" );
       	        ps.println( "\t\t\t// register entire node for regeneration" );
       	        ps.println( "\t\t\t// last parameter can be any object, it is passed to \"optimize\" method" );
       	        ps.println( "\t\t\t// as the \"param\" parameter" );
       	        ps.println( "\t\t\treplaceRange( route.getFirstTokenOffset(), route.getLastTokenOffset(), route );" );
       	        ps.println( "\t\t}" );
       	        ps.println( "\t}" );
       	        ps.println( "" );
       	    }
       	    
       	    ps.println( "\t/** Called to regenerate a portion of the text in a file." );
       	    ps.println( "\t *" );
       	    ps.println( "\t *  @param tp object that takes regenerated text, similar to a PrintStream" );
       	    ps.println( "\t *  @param param Object passed to \"replaceRange\" in \"attemptOptimization\" method above" );
       	    ps.println( "\t *  @param startTokenOffset offset of first token in sequence being regenerated" );
       	    ps.println( "\t *  @param endTokenOffset offset of last token in sequence being regenerated" );
       	    ps.println( "\t */" );
       	    ps.println( "\tpublic void optimize( TokenPrinter tp, Object param, int startTokenOffset, int endTokenOffset ) {" );
       	    ps.println( "\t\t// TODO: user defined" );
       	    ps.println( "\t\t// if nothing done here, entire range is removed" );
       	    ps.println( "\t}" );
       	    ps.println( "" );
        	    
    	    ps.println( "}" );
    	    ps.flush();
    	    ps.close();
    	} catch ( Exception e ) {
    	    e.printStackTrace();
    	}
    }

    public String[] getFieldNames( String nodeName ) {
        String[] fieldNameList;
        Hashtable hashTable = VRML97.getFieldTable( nodeName );
        if ( hashTable == null ) {
            return( null );
        } else {
            int size = hashTable.size();
            fieldNameList = new String[ size ];
            Enumeration keys = hashTable.keys();
            int resultIdx = 0;
            while ( keys.hasMoreElements() ) {
                String x = (String)keys.nextElement();
                if ( resultIdx < size ) {
                    fieldNameList[ resultIdx++ ] = x;
                }
            }
            return( fieldNameList );
        }
    }

  
    void genOptionConstraints( PrintStream ps, String constantName, boolean isBool, int minVal, int maxVal, int incVal ) {
        if ( !isBool ) {
            ps.println( "\t\tif ( offset == " + constantName + " ) {" );
            ps.println( "\t\t\treturn( new IntegerConstraints( " + minVal + ", " + maxVal + ", " + incVal + " ));" );
            ps.println( "\t\t}" );
        }
    }
    
    void genOptionValueSet( PrintStream ps, String constantname, boolean isBool, String varName ) {
        ps.println( "\t\tif ( offset == " + constantname + " ) {" );
        if ( isBool ) {
            ps.println( "\t\t\t" + varName + " = optionValueToBoolean( value );" );
        } else {
            ps.println( "\t\t\t" + varName + " = optionValueToInt( value );" );
        }
        ps.println( "\t\t}" );
    }
    
    void genOptionValueReturn( PrintStream ps, String constantname, boolean isBool, String varName ) {
        ps.println( "\t\tif ( offset == " + constantname + " ) {" );
        if ( isBool ) {
            ps.println( "\t\t\treturn( booleanToOptionValue( " + varName + " ));" );
        } else {
            ps.println( "\t\t\treturn( intToOptionValue( " + varName + " ));" );
        }
        ps.println( "\t\t}" );
    }

    void genOptionTypeReturn( PrintStream ps, String constantName, boolean isBool ) {
   	    ps.println( "\t\tif ( offset == " + constantName + " ) {" );
        if ( isBool ) {
            ps.println( "\t\t\treturn( Boolean.TYPE );" );
        } else {
            ps.println( "\t\t\treturn( Integer.TYPE );" );
        }
        ps.println( "\t\t}" );
    }
    
    void genOptionLabelReturn( PrintStream ps, String constantName, String optionLabel ) {
   	    ps.println( "\t\tif ( offset == " + constantName + " ) {" );
        ps.println( "\t\t\treturn( \"" + optionLabel + "\" );" );
        ps.println( "\t\t}" );
    }
    
    void genOptionBool( PrintStream ps, String variable, boolean boolval ) {
        ps.println( "\t\t" + variable + " = " + boolval + ";" );
    }
    
    void genOptionDefault( PrintStream ps, String variable, int val ) {
        ps.println( "\t\t" + variable + " = " + val + ";" );
    }
    
    String genPackageName( String shortDesc ) {
        codeveloperFile = strToName( shortDesc );
        return( "com.trapezium.codeveloper." + codeveloperFile );
    }
    
    String strToUpper( String s ) {
        StringBuffer sb = new StringBuffer();
        int len = s.length();
        for ( int i = 0; i < len; i++ ) {
            char x = s.charAt( i );
            if ( Character.isLetterOrDigit( x )) {
                if ( Character.isLowerCase( x )) {
                    x = Character.toUpperCase( x );
                }
                sb.append( x );
            } else if ( Character.isSpace( x )) {
                sb.append( '_' );
            }
        }
        return( sb.toString() );
    }
    
    String strToName( String s ) {
        StringBuffer sb = new StringBuffer();
        int len = s.length();
        if ( len == 0 ) {
            return( "empty" );
        }
        if ( !Character.isLetter( s.charAt( 0 ))) {
            sb.append( "J" );
        }
        for ( int i = 0; i < len; i++ ) {
            char x = s.charAt( i );
            if ( Character.isLetterOrDigit( x )) {
                sb.append( x );
            } else if ( Character.isSpace( x )) {
                sb.append( '_' );
            }
        }
        return( sb.toString() );
    }
}
